# Go Color Term

Welcome to Go Color Term! the place where your monochromatic terminal meets a colorful world!

This library allows to apply _ANSI Escape Sequences_ to alter the style of the rendered text on a Terminal.

## Supported Operating Systems and Terminals
* macOS: tested and working on iTerm2.
* Linux: not tested yet, but should work.
* Windows: not supported yet, erratic behaviour.

## Examples

Check the [accompanying repository](https://github.com/nelsonghezzi/go-color-term-examples) with a ready-to-run app which recopiles various examples to showcase the library API. 

## How to use

This library provides several ways to add color to your output, tailored for different use cases.

The idea is to provide with the simplest way to render styled text for each situation.

| Method                         | Use Case |
|--------------------------------|----------|
| `coloring.*` utility functions |          |
| `StyleBuilder`                 |          |
| `DecoratedText`                |          |
| `SentenceBuilder`              |          |

The next sections describes each of these approaches in more detail.

In the examples below, whenever you encounter the string sequence `ESC`, it symbolically refers the the byte `0x1B` (`27` in decimal or `33` in octal) which is the control character used to start the ANSI escape sequences.

### `coloring.*` utility functions

This are utility functions that lets you apply simple style attributes to a provided string, like:

```go
coloring.Red("Fire truck")
```

This will produce the following escaped string:

```
ESC[31;mFire truckESC[39;m
```

Which be can decompose for analysis into:

```
 Sets red      Resets text color
text color        to default
    |                 |
    v                 v
--------          --------
ESC[31;mFire truckESC[39;m
        ----------
            ^
            |
     Provided string
```

Of course you can combine multiple styles by passing the output of one function to another:

```go
coloring.Bold(coloring.Red("Wolf"))
```

This is probably fine for a few function calls, but can become difficult to read if the combination grows larger.

Also, this approach, while it works, doesn't generate the most efficient escape sequences:

```
ESC[1;mESC[31;mWolfESC[39;mESC[22;m
```

A more compact sequence for the same style would be `ESC[1;31;mWolfESC[0;m`, which is the topic of the next section.

The full list of utility functions is:
* `Black(s string)`
* `Red(s string)`
* `Green(s string)`
* `Yellow(s string)`
* `Blue(s string)`
* `Magenta(s string)`
* `Cyan(s string)`
* `White(s string)`
* `BgBlack(s string)`
* `BgRed(s string)`
* `BgGreen(s string)`
* `BgYellow(s string)`
* `BgBlue(s string)`
* `BgMagenta(s string)`
* `BgCyan(s string)`
* `BgWhite(s string)`
* `Bold(s string)`
* `Faint(s string)`
* `Italic(s string)`
* `Underline(s string)`
* `Blink(s string)`
* `Invert(s string)`
* `Conceal(s string)`
* `Strikethrough(s string)`

See [coloring/utility.go](https://github.com/nelsonghezzi/go-color-term/blob/main/coloring/utility.go) for implementation details.

### `StyleBuilder`

When you need to apply multiple styles to the same word/phrase you can use a `StyleBuilder`:

```go
boldRedFiretruck := coloring.For("fire truck").Bold().Red()
```

Then you can use it as a `string` argument for formatting functions:

```go
fmt.Printf("Here comes the %s\n", boldRedFiretruck)
```

That's because `StyleBuilder` implements the [`Stringer`](https://golang.org/pkg/fmt/#Stringer) interface.

If you need the styled `string` for use in other contexts not expecting a `Stringer`, just call the `String()` func on the `StyleBuilder`:

```go
styledFiretruck := boldRedFiretruck.String()

// pass or use the styledFiretruck string as needed
```

Styles generated by `StyleBuilder` combine multiple attributes in a single escape sequence and **resets all the styles*** at the end. For example, the following code:

```go
styledWolf := coloring.For("Wolf").Red().Bold().Underline().Blink().String()
````

creates the escaped string:

```
ESC[31;1;4;5;mWolfESC[0;m
```

If you pretend to reuse the same style for different `string`s, you can do so by using the `New()` shorthand, and then calling `Func()` at the end, which will give you a `ColorizerFunc` that can be invoked with different `string`s:

```go
boldRed := coloring.New().Bold().Red().Func()

fmt.Printf("Here comes the %s to extinguish the %s\n", boldRed("fire truck"), boldRed("fire"))
```

Whether to use `For(string)` or `New()` + `Func()` will be a matter of reusability needs.

### `DecoratedText`

TBD

### `SentenceBuilder`

This is perhaps the more daunting form of adding style attributes, but in return it gives the more fine grained control of when to start and end each style attribute.

## Licence

TBD

## Contributing

Feel free to add contributions in the form of issues/feature requests, pull requests discussions
